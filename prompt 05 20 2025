I have an existing Laravel + React + TypeScript + InertiaJS + ShadCN application with full user authentication already set up.

I want to implement multi-tenancy using stancl/tenancy (single-database mode) to support multiple companies. Each authenticated user can belong to one or more companies and should be able to switch between companies via a company switcher component on the sidebar.

The main goal is to load data such as Chart of Accounts per company, ensuring the URL remains clean (no company slug or ID in the path). The active company should be stored in session, cookie, or localStorage, and switching between companies should not cause a page reload or route change — just a soft update of the current data (e.g., still on /chart-of-accounts, but showing data for Company B instead of Company A).

Key Requirements:
Use Stancl/tenancy in single-database mode, where company-specific data (like chart of accounts) are distinguished using a company_id foreign key.

Use session or cookies (or possibly localStorage) to persist the active company between requests.

Provide a CompanySwitcher component in the React (Inertia) sidebar, showing the list of companies the user has access to.

When a company is selected, store the active company in session/cookie, update the backend Laravel context, and reload the page data via Inertia, without redirecting the user to a different route.

Ensure that all tenant-aware queries (e.g., ChartOfAccount::all()) only show data for the currently selected company.

Maintain a clean URL like /chart-of-accounts, regardless of the selected company.

Stancl documentation
Installation
Laravel 9.0 or higher is needed.

Require the package using composer:

composer require stancl/tenancy

Then run the following command:

php artisan tenancy:install

It will create:

migrations
a config file (config/tenancy.php),
a routes file (routes/tenant.php),
and a service provider file app/Providers/TenancyServiceProvider.php
Then add the service provider to your bootstrap/providers.php file:

return [
App\Providers\AppServiceProvider::class,
App\Providers\TenancyServiceProvider::class, // <-- here
];

And finally, if you want to use a different central database than the one defined by DB_CONNECTION in the file .env, name your central connection (in config/database.php) central — or however else you want, but make sure it's the same name as the tenancy.central_connection config.

Configuration
The package is highly configurable. This page covers what you can configure in the config/tenancy.php file, but note that many more things are configurable. Some things can be changed by extending classes (e.g. the Tenant model), and many things can be changed using static properties. These things will usually be mentioned on the respective pages of the documentation, but not every time. For this reason, don't be afraid to dive into the package's source code — whenever the class you're using has a public static property, it's intended to be configured.

Static properties
You can set static properties like this (example):

\Stancl\Tenancy\Middleware\InitializeTenancyByDomain::$onFail = function () {
return redirect('https://my-central-domain.com/');
};

A good place to put these calls is your app/Providers/TenancyServiceProvider's boot() method.

Tenant model
tenancy.tenant_model

This config specifies what Tenant model should be used by the package. There's a high chance you're using a custom model, as instructed to by the Tenants page, so be sure to change it in the config.

Unique ID generator
tenancy.id_generator

The Stancl\Tenancy\Database\Concerns\GeneratesIds trait, which is applied on the default Tenant model, will generate a unique ID (uuid by default) if no tenant id is supplied.

If you wish to use autoincrement ids instead of uuids:

set this config key to null, or create a custom tenant model that doesn't use this trait
update the tenants table migration to use an incrementing column type instead of string
update the domains table migration tenant_id column to the same type as tenants id
Domain model
tenancy.domain_model

Similar to the Tenant model config. If you're using a custom model for domains, change it in this config. If you're not using domains (e.g. if you're using path or request data identification) at all, ignore this config key altogether.

Central domains
tenancy.central_domains

The list of domains that host your central app. This is used by (among other things):

the PreventAccessFromCentralDomains middleware, to prevent access from central domains to tenant routes,
the InitializeTenancyBySubdomain middleware, to check whether the current hostname is a subdomain on one of your central domains.
Bootstrappers
tenancy.bootstrappers

This config array lets you enable, disable or add your own tenancy bootstrappers.

Database
If you're using Laravel Sail, please refer the Laravel Sail integration guide.

This section is relevant to the multi-database tenancy, specifically, to the DatabaseTenancyBootstrapper and logic that manages tenant databases.

See this section in the config, it's documented with comments.

Cache
tenancy.cache.\*

This section is relevant to cache separation, specifically, to the CacheTenancyBootstrapper.

Note: To use the cache separation, you need to use a cache store that supports tagging, which is usually Redis.

See this section in the config, it's documented with comments.

Filesystem
tenancy.filesystem.\*

This section is relevant to storage separation, specifically, to the FilesystemTenancyBootstrapper.

See this section in the config, it's documented with comments.

Redis
tenancy.redis.\*

This section is relevant to Redis data separation, specifically, to the RedisTenancyBootstrapper.

Note: To use this bootstrapper, you need phpredis.

See this section in the config, it's documented with comments.

Features
tenancy.features

This config array lets you enable, disable or add your own feature classes.

Migration parameters
tenancy.migration_parameters

This config array lets you set parameters used by default when running the tenants:migrate command (or when this command is executed using the MigrateDatabase job). Of course, all of these parameters can be overridden by passing them directly in the command call, be it in CLI or using Artisan::call().

Seeder parameters
tenancy.seeder_parameters

The same as migration parameters, but for tenants:seed and the SeedDatabase job.

The two applications
You will find these two terms a lot throughout this documentation:

central application
tenant application
Those terms refer to the parts of your application that house the central logic, and the tenant logic.

The tenant application is executed in tenant context — usually with the tenant's database, cache, etc. The central application is executed when there is no tenant.

The central application will house your signup page where tenants are created, your admin panel used to manage your tenants, etc.

The tenant application will likely house the larger part of your application — the real service being used by your tenants.

Domains
Note: Domains are optional. If you're using path or request data identification, you don't need to worry about them.

To add a domain to a tenant, use the domains relationship:

$tenant->domains()->create([
'domain' => 'acme',
]);

If you use the subdomain identification middleware, the example above will work for acme.{any of your central domains}. If you use the domain identification middleware, use the full hostname like acme.com. If you use the combined domain/subdomain identification middleware, you should use both acme as a subdomain and acme.com for the domain.

Note that starting with Laravel 8 and up, Laravel TrustHost middleware is enabled by default (see laravel/laravel#5477). This blocks Domain-based tenant identification since these requests will be treated as 'untrusted' unless added as a trusted host. You can either comment out this middleware in your App\Http\Kernel.php, or you can add the custom tenant domains in the App\Http\Middleware\TrustHosts.php hosts() method.

To retrieve the current domain model (when using domain identification), you may access the $currentDomain public static property on DomainTenantResolver.

Local development
For local development, you may use \*.localhost domains (like foo.localhost) for tenants. On many operating systems, these work the same way as localhost.

If you're using Valet, you may want to use e.g. saas.test for the central domain and foo.saas.test, bar.saas.test etc for tenant domains. Alternatively, if you want to use multiple second-level domains, you can use the valet link command to attach additional domains to the project. For example: valet link bar.test

Event system
This package is heavily based around events, which makes it incredibly flexible.

By default, the events are configured in such a way that the package works like this:

A request comes in for a tenant route and hits an identification middleware
The identification middleware finds the correct tenant and runs
$this->tenancy->initialize($tenant);

The Stancl\Tenancy\Tenancy class sets the $tenant as the current tenant and fires a TenancyInitialized event
The BootstrapTenancy class catches the event and executes classes known as tenancy bootstrappers.
The tenancy bootstrappers make changes to the application to make it "scoped" to the current tenant. This by default includes:
Switching the database connection
Replacing CacheManager with a scoped cache manager
Suffixing filesystem paths
Making queues store the tenant id & initialize tenancy when being processed
Again, all of the above is configurable. You might even disable all tenancy bootstrappers, and just use tenant identification and scope your app manually around the tenant stored in Stancl\Tenancy\Tenancy. The choice is yours.

TenancyServiceProvider
This package comes with a very convenient service provider that's added to your application when you install the package. This service provider is used for mapping listeners to events specific to the package and is the place where you should put any tenancy-specific service container calls — to not pollute your AppServiceProvider.

Note that you can register listeners to this package's events anywhere you want. The event/listener mapping in the service provider exists only to make your life easier. If you want to register the listeners manually, like in the example below, you can.

Event::listen(TenancyInitialized::class, BootstrapTenancy::class);

Bootstrapping tenancy
By default, the BootstrapTenancy class is listening to the TenancyInitialized event (exactly as you can see in the example above). That listener will execute the configured tenancy bootstrappers to transition the application into the tenant's context. You can read more about this on the tenancy bootstrappers page.

Conversely, when the TenancyEnded event fires, the RevertToCentralContext event transitions the app back into the central context.

Job pipelines
You may want to use job pipelines even in projects that don't use this package — I think they're a cool concept so they're extracted into a separate package: github.com/stancl/jobpipeline

The JobPipeline is a simple, yet extremely powerful class that lets you convert any (series of) jobs into event listeners.

You may use a job pipeline like any other listener, so you can register it in the TenancyServiceProvider, EventServiceProvider using the $listen array, or in any other place using Event::listen() — up to you.

Creating job pipelines
To create a job pipeline, start by specifying the jobs you want to use:

use Stancl\JobPipeline\JobPipeline;
use Stancl\Tenancy\Jobs\{CreateDatabase, MigrateDatabase, SeedDatabase};

JobPipeline::make([
CreateDatabase::class,
MigrateDatabase::class,
SeedDatabase::class,
])

Then, specify what variable you want to pass to the jobs. This will usually come from the event.

use Stancl\JobPipeline\JobPipeline;
use Stancl\Tenancy\Jobs\{CreateDatabase, MigrateDatabase, SeedDatabase};
use Stancl\Tenancy\Events\TenantCreated;

JobPipeline::make([
CreateDatabase::class,
MigrateDatabase::class,
SeedDatabase::class,
])->send(function (TenantCreated $event) {
return $event->tenant;
})

Next, decide if you want to queue the pipeline. By default, pipelines are synchronous (= not queued).

If you do want pipelines to be queued by default, you can do that by setting a static property: \Stancl\JobPipeline\JobPipeline::$shouldBeQueuedByDefault = true;

use Stancl\Tenancy\Events\TenantCreated;
use Stancl\JobPipeline\JobPipeline;
use Stancl\Tenancy\Jobs\{CreateDatabase, MigrateDatabase, SeedDatabase};

JobPipeline::make([
CreateDatabase::class,
MigrateDatabase::class,
SeedDatabase::class,
])->send(function (TenantCreated $event) {
return $event->tenant;
})->shouldBeQueued(true),

Finally, convert the pipeline to a listener and bind it to an event:

use Stancl\Tenancy\Events\TenantCreated;
use Stancl\JobPipeline\JobPipeline;
use Stancl\Tenancy\Jobs\{CreateDatabase, MigrateDatabase, SeedDatabase};
use Illuminate\Support\Facades\Event;

Event::listen(TenantCreated::class, JobPipeline::make([
CreateDatabase::class,
MigrateDatabase::class,
SeedDatabase::class,
])->send(function (TenantCreated $event) {
return $event->tenant;
})->shouldBeQueued(true)->toListener());

Note that you can use job pipelines even for converting single jobs to event listeners. That's useful if you have some logic in job classes and don't want to create listener classes just to be able to run these jobs as a result of an event being fired.

Available events
Note: Some database events (DatabaseMigrated, DatabaseSeeded, DatabaseRolledback and possibly others) are fired in the tenant context. Depending on how your application bootstraps tenancy, you might need to be specific about interacting with the central database in these events' listeners — that is, if you need to.

Note: All events are located in the Stancl\Tenancy\Events namespace.

Tenancy
InitializingTenancy
TenancyInitialized
EndingTenancy
TenancyEnded
BootstrappingTenancy
TenancyBootstrapped
RevertingToCentralContext
RevertedToCentralContext
Note the difference between initializing tenancy and bootstrapping tenancy. Tenancy is initialized when a tenant is loaded into the Tenancy object. Whereas bootstrapping happens as a result of initialization — if you're using automatic tenancy, the BootstrapTenancy class is listening to the TenancyInitialized event and after it's done executing bootstrappers, it fires an event saying that tenancy was bootstrapped. You want to use the bootstrapped event if you want to execute something after the app has been transitioned to the tenant context.

Tenant
The following events are dispatched as a result of Eloquent events being fired in the default Tenant implementation (the most often used events are bold):

CreatingTenant
TenantCreated
SavingTenant
TenantSaved
UpdatingTenant
TenantUpdated
DeletingTenant
TenantDeleted
Domain
These events are optional. They're only relevant to you if you're using domains for your tenants.

CreatingDomain
DomainCreated
SavingDomain
DomainSaved
UpdatingDomain
DomainUpdated
DeletingDomain
DomainDeleted
Database
These events are also optional. They're relevant to you if you're using multi-database tenancy:

CreatingDatabase
DatabaseCreated
MigratingDatabase
DatabaseMigrated
SeedingDatabase
DatabaseSeeded
RollingBackDatabase
DatabaseRolledBack
DeletingDatabase
DatabaseDeleted
Resource syncing
SyncedResourceSaved
SyncedResourceChangedInForeignDatabase

Routes
This package has a concept of central routes and tenant routes. Central routes are only available on central domains, and tenant routes are only available on tenant domains. If you don't use domain identification, then all routes are always available and you may skip the details about preventing access from other domains.

Central routes
You may register central routes in routes/web.php or routes/api.php like you're used to. However, you need to make one small change to your RouteServiceProvider.

Note: Since Laravel 11, there isn't a RouteServiceProvider, so you can instead wrap your central routes in a Route::domain(...)->group(...) call. See the quickstart guide for an example.

You don't want central routes — think landing pages and sign up forms — to be accessible on tenant domains. For that reason, register them in such a way that they're only accessible on your central domains:

// RouteServiceProvider

protected function mapWebRoutes()
{
foreach ($this->centralDomains() as $domain) {
        Route::middleware('web')
            ->domain($domain)
->namespace($this->namespace)
->group(base_path('routes/web.php'));
}
}

protected function mapApiRoutes()
{
foreach ($this->centralDomains() as $domain) {
        Route::prefix('api')
            ->domain($domain)
->middleware('api')
->namespace($this->namespace)
->group(base_path('routes/api.php'));
}
}

protected function centralDomains(): array
{
return config('tenancy.central_domains', []);
}

Note: If you're using multiple central domains, you can't use route names, because different routes (= different combinations of domains & paths) can't share the same name. If you need to use a different central domain for testing, use config()->set() in your TestCase setUp().

Tenant routes
You may register tenant routes in routes/tenant.php. These routes have no middleware applied on them, and their controller namespace is specified in app/Providers/TenancyServiceProvider.

By default, you will see the following setup:

Route::middleware([
'web',
InitializeTenancyByDomain::class,
PreventAccessFromCentralDomains::class,
])->group(function () {
Route::get('/', function () {
return 'This is your multi-tenant application. The id of the current tenant is ' . tenant('id');
});
});

Routes within this group will have the web middleware group, an initialization middleware, and finally, a middleware related to the section below applied on them.

You may do the same for the api route group, for instance.

Also, you may use different initialization middleware than the domain one. For a full list, see the Tenant identification page.

Conflicting paths
Due to the order in which the service providers (and as such, their routes) are registered, tenant routes will take precedence over central routes. So if you have a / route in your routes/web.php file but also routes/tenant.php, the tenant route will be used on tenant domains.

However, tenant routes that don't have their central counterpart will still be accessible on central domains and will result in a "Tenant could not be identified on domain ..." error. To avoid this, use the Stancl\Tenancy\Middleware\PreventAccessFromCentralDomains middleware on all of your tenant routes. This middleware will abort with a 404 if the user is trying to visit a tenant route on a central domain.

Tenancy bootstrappers
Tenancy bootstrappers are classes which make your application tenant-aware in such a way that you don't have to change a line of your code, yet things will be scoped to the current tenant.

The package comes with these bootstrappers out of the box:

Database tenancy bootstrapper
The database tenancy bootstrapper switches the default database connection to tenant after it constructs the connection for that tenant.

Customizing databases

Note that only the default connection is switched. If you use another connection explicitly, be it using DB::connection('...'), a model getConnectionName() method, or a model trait like CentralConnection, it will be respected. The bootstrapper doesn't force any connections, it merely switches the default one.

Cache tenancy bootstrapper
The cache tenancy bootstrapper replaces the Laravel's CacheManager instance with a custom CacheManager that adds tags with the current tenant's ids to each cache call. This scopes cache calls and lets you selectively clear tenants' caches:

php artisan cache:clear --tag=tenant_123

Note that you must use a cache store that supports tagging, e.g. Redis.

Filesystem tenancy bootstrapper
The filesystem bootstrapper makes your app's Storage facade and the storage_path() and asset() helpers tenant-aware by modifying the paths they return.

Note: If you want to bootstrap filesystem tenancy differently (e.g. provision an S3 bucket for each tenant), you can absolutely do that. Take a look at the package's bootstrappers to get an idea of how to write one yourself, and feel free to implement it any way you want.

Storage path helper
The bootstrapper suffixes the path returned by storage_path() to make the helper tenant-aware.

The suffix is built by appending the tenant key to your suffix_base. The suffix_base is tenant by default, but feel free to change it in the tenancy.filesystem config. For example, the suffix will be tenant42 if the tenant's key is 42 and the suffix_base is tenant.
After the suffixing, storage_path() helper returns "/$path_to_your_application/storage/tenant42/"
Since storage_path() will be suffixed, your folder structure will look like this:

The folder structure

Logs will be saved in storage/logs regardless of any changes to storage_path() and regardless of the tenant.

Storage facade
The bootstrapper also makes the Storage facade tenant-aware by suffixing the roots of disks listed in config('tenancy.filesystem.disks') and by overriding the disk roots in config('tenancy.filesystem.root_override') (disk root = the disk path used by the Storage facade).

The root of each disk listed in config('tenancy.filesystem.disks') will be suffixed. Doing that alone could cause unwanted behavior since Laravel does its own suffixing, so the filesystem config has the root_override section, which lets you override the disk roots after tenancy has been initialized:

// Tenancy config (tenancy.filesystem.root_override)
// %storage_path% gets replaced by storage_path()'s output
// E.g. Storage::disk('local')->path('') will return "/$path_to_your_application/storage/tenant42/app"
// (Given a suffix_base of 'tenant' and a tenant with a key of `42`. Same as in the example above in the Storage path helper section)
'root_override' => [
'local' => '%storage_path%/app/',
'public' => '%storage_path%/app/public/',
],

To make the tenant-aware Storage facade work with a custom disk, add the disk's name to config('tenancy.filesystem.disks') and if the disk is local, override its root in config('tenancy.filesystem.root_override') as shown above. With S3, overriding the disk roots is not necessary – Storage::disk('s3')->path('foo.txt') will return /tenant42/foo.txt.

Assets
The filesystem bootstrapper makes the asset() helper link to the files of the current tenant. By default, the bootstrapper makes the helper output a URL pointing to the TenantAssetsController (/tenancy/assets/...), which returns a file response:

// TenantAssetsController
return response()->file(storage_path('app/public/' . $path));

The package expects the assets to be stored in your tenant's app/public/ directory. For global assets (non-private assets shared among all tenants), you may want to create a disk and use URLs from that disk instead. For example:

Storage::disk('branding')->url('header-logo.png');

To access global assets such as JS/CSS assets, you can use global_asset() and mix().

Configuring the asset URL (ASSET_URL in your .env) changes the asset() helper's behavior – when the asset URL is set, the bootstrapper will suffix the configured asset URL (the same way storage_path() gets suffixed), and make the asset() helper output that instead of a path to the TenantAssetsController.

You can disable tenancy of asset() in the config (tenancy.filesystem.asset_helper_tenancy) and explicitly use tenant_asset() instead. tenant_asset() always returns a path to the TenantAssetController: tenant_asset('foo.txt') returns your-site.com/tenancy/assets/foo.txt. You may want to do that if you're facing issues using a package that utilizes asset() inside the tenant app.

Before using the asset() helper, make sure to assign the identification middleware you're using in your app to TenantAssetsController's $tenancyMiddleware:

// TenancyServiceProvider (don't forget to import the classes)

public function boot()
{
// Update the middleware used by the asset controller
TenantAssetsController::$tenancyMiddleware = InitializeTenancyByDomainOrSubdomain::class;
}

Queue tenancy bootstrapper
This bootstrapper adds the current tenant's ID to the queued job payloads, and initializes tenancy based on this ID when jobs are being processed.

The bootstrapper has a static $forceRefresh property which is false by default. Setting the property to true will make tenancy re-initialize for each queued job. This is useful when you're changing the tenant's state (e.g. properties in the data column) and want the next job to initialize tenancy again with the new data. Features like the Tenant Config are only executed when tenancy is initialized, so the re-initialization is needed in some cases.

You can read more about this on the Queues page:

Queues

Redis tenancy bootstrapper
If you're using Redis calls (not cache calls, direct Redis calls) inside the tenant app, you will want to scope Redis data too. To do this, use this bootstrapper. It changes the Redis prefix for each tenant.

Note that you need phpredis, predis won't work.

Writing custom bootstrappers
If you want to bootstrap tenancy for something not covered by this package — or something covered by this package, but you want different behavior — you can do that by creating a bootstrapper class.

The class must implement the Stancl\Tenancy\Contracts\TenancyBootstrapper interface:

namespace App;

use Stancl\Tenancy\Contracts\TenancyBootstrapper;
use Stancl\Tenancy\Contracts\Tenant;

class MyBootstrapper implements TenancyBootstrapper
{
public function bootstrap(Tenant $tenant)
{
// ...
}

    public function revert()
    {
        // ...
    }

}

Then, register it in the tenancy.bootstrappers config:

'bootstrappers' => [
Stancl\Tenancy\Bootstrappers\DatabaseTenancyBootstrapper::class,
Stancl\Tenancy\Bootstrappers\CacheTenancyBootstrapper::class,
Stancl\Tenancy\Bootstrappers\FilesystemTenancyBootstrapper::class,
Stancl\Tenancy\Bootstrappers\QueueTenancyBootstrapper::class,

    App\MyBootstrapper::class,

],

Optional features
"Features" are classes that provide additional functionality that's not needed for the core tenancy logic. Out of the box, the package comes with these Features:

UserImpersonation for generating impersonation tokens for users of a tenant's DB from other contexts
TelescopeTags for adding tags with the current tenant id to Telescope entries
TenantConfig for mapping keys from the tenant storage into the application config
CrossDomainRedirect for adding a domain() macro on RedirectResponse letting you change the intended hostname of the generated route
UniversalRoutes for route actions that work in both the central & tenant context
ViteBundler for making Vite generate the correct asset paths
All of the package's Features are in the Stancl\Tenancy\Features namespace.

You may register features by adding their class names to the tenancy.features config
User impersonation
This package comes with a feature that lets you impersonate users inside tenant databases. This feature works with any identification method and any stateful auth guard — even if you use multiple.

Note: If you're currently using a non-stateful auth guard (e.g., Laravel Sanctum's guard), you can still utilize user impersonation by passing a stateful guard to tenancy()->impersonate() (e.g. the 'web' guard).

How it works
You generate an impersonation token and store it in the central database, in the tenant_user_impersonation_tokens table.

Each record in the table holds the following data:

The token value (128 character string)
The tenant's id
The user's id
The name of the auth guard
The URL to redirect to after the impersonation takes place
You visit an impersonation route that you create — though little work is needed on your side, your route will mostly just call a method provided by the feature. This route is a tenant route, meaning it's on the tenant domain if you use domain identification, or prefixed with the tenant id if you use path identification.

This route tries to find a record in that table based on the token, and if it's valid, it authenticates you with the stored user id against the auth guard and redirects you to the stored URL.

If the impersonation succeeds, the token is deleted from the database.

All tokens expire after 60 seconds by default, and this TTL can be customized — see the section at the very bottom.

Enabling the feature
To enable this feature, go to your config/tenancy.php file and make sure the following class is in your features part of the config:

Stancl\Tenancy\Features\UserImpersonation::class,

Next, publish the migration for creating the table with impersonation tokens:

php artisan vendor:publish --tag=impersonation-migrations

And finally, run the migration:

php artisan migrate

Usage
First, you need to create a tenant route that looks like this:

use Stancl\Tenancy\Features\UserImpersonation;

// We're in your tenant routes!

Route::get('/impersonate/{token}', function ($token) {
    return UserImpersonation::makeResponse($token);
});

// Of course use a controller in a production app and not a Closure route.
// Closure routes cannot be cached.

Note that the route path or name are completely up to you. The only logic that the package does is generating tokens, verifying tokens, and doing the impersonated user log in.

Then, to use impersonation in your app, generate a token like this:

// Let's say we want to be redirected to the dashboard
// after we're logged in as the impersonated user.
$redirectUrl = '/dashboard';

$token = tenancy()->impersonate($tenant, $user->id, $redirectUrl);

And redirect the user (or, presumably an "admin") to the route you created.

Domain identification
// Note: This is not part of the package, it's up to you to implement
// a concept of "primary domains" if you need them. Or maybe you use
// one domain per tenant. The package lets you do anything you want.
$domain = $tenant->primary_domain;
return redirect("https://$domain/impersonate/{$token->token}");

Path identification
// Make sure you use the correct prefix for your routes.
return redirect("{$tenant->id}/impersonate/{$token->token}");

And that's it. The user will be redirected to your impersonation route, logged in as the impersonated user, and finally redirected to your redirect URL.

Custom auth guards
Note: The auth guard used by user impersonation has to be stateful (it has to implement the Illuminate\Contracts\Auth\StatefulGuard interface).

If you're using multiple auth guards, you may want to specify what auth guard the impersonation logic should use.

To do this, simply pass the auth guard name as the fourth argument to the impersonate() method. So to expand on our example above:

tenancy()->impersonate($tenant, $user->id, $redirectUrl, 'jwt');

Customization
You may customize the TTL of impersonation tokens by setting the following static property to the amount of seconds you want to use:

Stancl\Tenancy\Features\UserImpersonation::$ttl = 120; // 2 minutes
Automatic mode
By default, the package bootstraps tenancy automatically in the background. This means that when a tenant is identified (usually using middleware), the default database/cache/filesystem/etc is switched to that tenant's context. You can read more about this on the Tenancy bootstrappers page.

The flow goes like this:

TenancyInitialized fired → BootstrapTenancy listens → executes tenancy bootstrappers

It's recommended to use this mode, because:

Separation of concerns. Tenancy happens one layer below your application. If you need to change the details of how tenancy is bootstrapped, you can do that without having to change a ton of your app code.
You don't have to think about the internals of how tenancy works when writing your application code. When you're writing the tenant part of the application, you're simply writing e.g. an e-commerce application, not a multi-tenant e-commerce application. No need to think about database connections when writing validation rules.
Great integration with other packages. Switching the default database connection (and other things) is the only way to integrate many packages into the tenant part of the application. For example, you can use Laravel Nova to manage resources inside the tenant application.
Manual mode
See: Automatic mode

If you wish to use the package only to keep track of the current tenant and make the application tenant-aware manually — without using the Tenancy bootstrappers, you can absolutely do that.

You may use the Stancl\Tenancy\Database\Concerns\CentralConnection and Stancl\Tenancy\Database\Concerns\TenantConnection model traits to make models explicitly use the given connections.

To create the tenant connection, set up the CreateTenantConnection listener:

// app/Providers/TenancyServiceProvider.php

Events\TenancyInitialized::class => [
Listeners\CreateTenantConnection::class,
],

This approach is generally discouraged, because you lose all of the benefits of the automatic mode, but there won't be any issues with the package if you decide to use the manual mode. You might not be able to integrate other packages as easily, but if for whatever reason it makes more sense for your project to use this approach, feel comfortable to do so.
Single-database tenancy
Single-database tenancy comes with lower devops complexity, but larger code complexity than multi-database tenancy, since you have to scope things manually, and won't be able to integrate some third-party packages.

It is preferable when you have too many shared resources between tenants, and don't want to make too many cross-database queries.

To use single-database tenancy, make sure you disable the DatabaseTenancyBootstrapper which is responsible for switching database connections for tenants.

You can still use the other tenancy bootstrappers to separate tenant caches, filesystems, etc.

Also make sure you have disabled the database creation jobs (CreateDatabase, MigrateDatabase, SeedDatabase ...) from listening to the TenantCreated event.

Concepts
In single-database tenancy, there are 4 types of models:

your Tenant model
primary models — models that directly belongTo tenants
secondary models — models that indirectly belongTo tenants
e.g. Comment belongsTo Post belongsTo Tenant
or more complex, Vote belongsTo Comment belongsTo Post belongsTo Tenant
global models — models that are not scoped to any tenant whatsoever
To scope your queries correctly, apply the Stancl\Tenancy\Database\Concerns\BelongsToTenant trait on primary models. This will ensure that all calls to your parent models are scoped to the current tenant, and that calls to their child relations are scoped through the parent relationships.

And that's it. Your models are now automatically scoped to the current tenant, and not scoped at all when there's no current tenant (e.g. in a central admin panel).

However, there's one edge case to keep in mind. Consider the following set-up:

class Post extends Model
{
use BelongsToTenant;

    public function comments()
    {
        return $this->hasMany(Comment::class);
    }

}

class Comment extends Model
{
public function post()
{
return $this->belongsTo(Post::class);
}
}

Looks correct, but you might still accidentally access another tenant's comments.

If you use this:

Comment::all();

then the model has no way of knowing how to scope that query, since it doesn't directly belong to the tenant. Also note that in practice, you really shouldn't be doing this much. You should ideally access secondary models through parent models in every single case.

However, sometimes you might have a use case where you really need to do that in the tenant context. For that reason, we also provide you with a BelongsToPrimaryModel trait, which lets you scope calls like the one above to the current tenant, by loading the parent relationship — which gets automatically scoped to the current tenant — on them.

So, to give you an example, you would do this:

class Comment extends Model
{
use BelongsToPrimaryModel;

    public function getRelationshipToPrimaryModel(): string
    {
        return 'post';
    }

    public function post()
    {
        return $this->belongsTo(Post::class);
    }

}

And this will automatically scope the Comment::all() call to the current tenant. Note that the limitation of this is that you need to be able to define a relationship to a primary model, so if you need to do this on the "Vote" in Vote belongsTo Comment belongsTo Post belongsTo Tenant, you need to define some strange relationship. Laravel supports HasOneThrough, but not BelongsToThrough, so you'd need to do some hacks around that. For that reason, I recommend avoiding these Comment::all()-type queries altogether.

Database considerations
Unique indexes
If you'd have a unique index such as:

$table->unique('slug');

in a standard non-tenant, or multi-database-tenant, application, you need to scope this unique index to the tenant, meaning you'd do this on primary models:

$table->unique(['tenant_id', 'slug']);

and this on secondary models:

// Imagine we're in a 'comments' table migration

$table->unique(['post_id', 'user_id']);

Validation
The unique and exists validation rules of course aren't scoped to the current tenant, so you need to scope them manually like this:

Rule::unique('posts', 'slug')->where('tenant_id', tenant('id'));

If that feels like a chore, you may use the Stancl\Tenancy\Database\Concerns\HasScopedValidationRules trait on your custom Tenant model to add methods for these two rules.

You'll be able to use these two methods:

// You may retrieve the current tenant using the tenant() helper.
// $tenant = tenant();

$rules = [
'id' => $tenant->exists('posts'),
'slug' => $tenant->unique('posts'),
]

Low-level database queries
And the final thing to keep in mind is that DB facade calls, or any other types of direct database queries, of course won't be scoped to the current tenant.

The package can only provide scoping logic for the abstraction logic that Eloquent is, it can't do anything with low level database queries.

Be careful with using them.

Making global queries
To disable the tenant scope, simply add withoutTenancy() to your query.

Customizing the column name
If you'd like to customize the column name to use e.g. team_id instead of tenant_id — if that makes more sense given your business terminology — you can do that by setting this static property in a service provider or some such class:

use Stancl\Tenancy\Database\Concerns\BelongsToTenant;

BelongsToTenant::$tenantIdColumn = 'team_id';

Note that this is universal to all your primary models, so if you use team_id somewhere, you use it everywhere — you can't use both team_id and tenant_id.

Tenant identification
The package lets you identify tenants using the following methods:

Domain identification (acme.com)
Subdomain identification (acme.yoursaas.com)
Domain OR subdomain identification (both of the above)
Path identification (yoursaas.com/acme/dashboard)
Request data identification (yoursaas.com/users?tenant=acme — or using request headers)
However, you're free to write additional tenant resolvers.

All of the identification methods mentioned above come with their own middleware. You can read more about each identification method below.

Domain identification
To use this identification method, make sure your tenant model uses the HasDomains trait.

Be sure to read the Domains page of the documentation.

The relationship is Tenant hasMany Domain. Store the hostnames in the domain column of the domains table.

This identification method comes with the Stancl\Tenancy\Middleware\InitializeTenancyByDomain middleware.

Subdomain identification
This is the exact same as domain identification, except you store the subdomains in the domain column of the domains table.

The benefit of this approach rather than storing the subdomain's full hostname in the domain column is that you can use this subdomain on any of your central domains.

The middleware for this method is Stancl\Tenancy\Middleware\InitializeTenancyBySubdomain.

Combined domain/subdomain identification
If you'd like to use subdomains and domains at the same time, use the Stancl\Tenancy\Middleware\InitializeTenancyByDomainOrSubdomain middleware.

Records that contain dots in the domain column will be treated as domains/hostnames (eg. foo.bar.com) and records that don't contain any dots will be treated as subdomains (eg. foo).

Path identification
Some applications will want to use a single domain, but use paths to identify the tenant. This would be when you want customers to use your branded product rather than giving them a whitelabel product that they can use on their own domains.

To do this, use the Stancl\Tenancy\Middleware\InitializeTenancyByPath middleware and make sure your routes are prefixed with /{tenant}.

use Stancl\Tenancy\Middleware\InitializeTenancyByPath;

Route::group([
'prefix' => '/{tenant}',
'middleware' => [InitializeTenancyByPath::class],
], function () {
Route::get('/foo', 'FooController@index');
});

If you'd like to customize the name of the argument (e.g. use team instead of tenant, look into the PathTenantResolver for the public static property).

Request data identification
You might want to identify tenants based on request data (headers or query parameters). Applications with SPA frontends and API backends may want to use this approach.

The middleware for this identification method is Stancl\Tenancy\Middleware\InitializeTenancyByRequestData.

You may customize what this middleware looks for in the request. By default, it will look for the X-Tenant header. If the header is not found, it will look for the tenant query parameter.

If you'd like to use a different header, change the static property:

use Stancl\Tenancy\Middleware\InitializeTenancyByRequestData;

InitializeTenancyByRequestData::$header = 'X-Team';

If you'd like to only use the query parameter identification, set the header static property to null:

use Stancl\Tenancy\Middleware\InitializeTenancyByRequestData;

InitializeTenancyByRequestData::$header = null;

If you'd like to disable the query parameter identification and only ever use the header, set the static property for the parameter to null:

use Stancl\Tenancy\Middleware\InitializeTenancyByRequestData;

InitializeTenancyByRequestData::$queryParameter = null;

Manually identifying tenants
See the manual initialization page to see how to identify tenants manually.

Customizing onFail logic
Each identification middleware has a static $onFail property that can be used to customize the behavior that should happen when a tenant couldn't be identified.

\Stancl\Tenancy\Middleware\InitializeTenancyByDomain::$onFail = function ($exception, $request, $next) {
return redirect('https://my-central-domain.com/');
Early identification
A slight "gotcha" with using the automatic approach to transition the application's context based on a route middleware is that route-level middleware is executed after controller constructors.

The implication of this is if you're using dependency injection to inject some services in the controller constructors, they will read from the central context, because route-level middleware hasn't initialized tenancy yet.

There are two ways to solve it, the former of which is preferable.

Not using constructor DI
You can inject dependencies in route actions, meaning: If you have a route that binds a Post model, you can still inject dependencies like this:

// Note that this is sort-of pseudocode. Notice the route action DI
// and just skim the rest :)

Route::get('/post/{post}/edit', 'PostController@edit');

class PostController
{
public function edit(Request $request, Post $post, Cloudinary $cloudinary)
    {
        if ($request->has('image')) {
$post->image_url = $cloudinary->store($request->file('image'));
}
}
}

If you don't like that because you access some dependency from many actions, consider creating a memoized method:

class PostController
{
protected Cloudinary $cloudinary;

    protected cloudinary(): Cloudinary
    {
        // If you don't like the service location here, injecting Application
        // in the controller constructor is one thing that's 100% safe.
        return $this->cloudinary ??= app(Cloudinary::class);
    }

    public function edit(Request $request, Post $post)
    {
        if ($request->has('image')) {
            $post->image_url = $this->cloudinary()->store(
                $request->file('image')
            );
        }
    }

}

Using a more complex middleware setup
Note: There's a new MW in v3 for preventing access from central domains. v2 was doing this a bit differently.

The manual for implementing this will come soon, for now you can look at how 2.x does this.

In short: The InitializeTenancy mw is part of the global middleware stack, which doesn't have access to route information, but is executed prior to controller constructors. The PreventAccessFromTenantDomains mw checks that we're vising a tenant route on a tenant domain, or a central route on a central domain — and if not, it aborts the request, either by 404 or by redirecting us to a home url on the tenant domain.
